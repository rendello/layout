TODO:
Decide the strategy: should all series be included in the base table, given
the series is not equivocal to another (ie, different versions of the
H-series), or should the base table truly be the base, and the special
characters be in their own groups?

Ie. The "łii → ᖡ" conversion only applies to certain dialects technically,
but the conversion should be included (in both directions) for any dialect,
because neither the latin consonant nor the syllabic symbol are ambiguous.
The characters may be used in names, for example, and there's no point
leaving them out.

With the "cascading hashtables" idea, the "ł" series should be applied on
top of the base table, casting its shadow onto it. But the base table could
easily have this character, and that would allow it to exist in all dialects.
Another idea is to always have the base table not be the true root, and have
additional dialect tables trailing it. This seems wasteful.

Indeed, the idea of having multiple, cascading hashtables may be wasteful.
I'd like to consider having one table per dialect, and perhaps even two, one
with the ai column using the restored syllabics like ᐁ, and one version with
the ᐊᐃ. Having the cascading effect is tempting in this case, but I'd be
forced to create a ᐊᐃ or ᐁ for every version of the table, which just adds
work, confusion, and CPU cycles.

Really, the differentiation in dialects comes down to, as I understand it, the
H series (plural).

ᕼᐊ → Nunavut
𑪴 → Natsilik
ᓴ → Eastern Nunavut (but S in Western Nunavut)
ᕹ → Nunavik

I'd like to look at webscrapes and see which of these characters are commonly
used.

In any case, the cascading hashtable, if necessary, is simple and elegant.
I have my doubts that it's needed, however.

Perhaps the "patching" can just be user preferences? They don't have to be
perfect hashing, just a regular hashtable. For example, latin-izing the ᖓ
series as "ng" vs "ŋ".

TODO: Figure out what "ᐂ" is and add it, probably. 

===

Have tables of symbols that are converted from, but not too. For example,
𑪶 is preferred to ᓯ̵, the latter should be converted from, but not to. Likewise,
ł is preferred to ɫ in latin text. 

Number of bytes for keys? Just count the number of [backslash]x per line.

Reverse shadowing: have the basic table contain all unambiguous Inuktitut
mappings, then just have a hole for the ambiguous mappings (ie. H-series),
and place the appropriate table pointer behind. Then the happy path maps
to the most used operations (non-h series). Of course, in this case, the
non-syllabic stuff still goes through the two tables per char.

Or, instead of returning a simple Option<str> from the tables, I could
also return a "h-series" variant, then use the current dialect to
deal with that. Same with the h-s series. I'm matching anyways on the
Some/None case, it'd just be another case or two.

Today:
- Unify the unambiguous tables into one base map,
- Create "convert from but not to" maps for syl→lat and vice versa
- Put charts on wikipedia page for ease of use -- Skip, too much work.

Maybe I can use the tables in my code to generate HTML tables. Ie. a
simple table with just the short versions, with a toggle for longs,
ng → ŋ, etc. That way the rules can be easily visualized, plus the tables
for nattilik, etc.

The 𑪶 series is sometimes "shr", sometimes "sh", sometimes "š".


===

HTML:

Add field button

Each field has a selector with:
["to_syl", "to_lat", "normalize_syl", "normalize_lat"]

Also, a selector at to of page to select layout:
[ A ]
[ B ]
[ C ]

Or

[A][B]
[C]

Maybe wrap the outputs in folds so they can be minimized.

Default:

[ to_syl ]
[ to_lat ]

===

Eliminate recursive function in converter (WASM doesn't do
TCO really)